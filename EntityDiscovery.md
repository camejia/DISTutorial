##Entity Discovery

Imagine that a program depicting a virtual world starts on a host. There are several other simulation participants that have been running and publishing entities for some time; perhaps ONE-SAF and JCATS have been publishing constructive entities for hours before our virtual simulation starts. How does our program learn of all the entities that have been published by other particpants, many not from the same vendor?

### What doesn't happen

One way to do this would be for the program, on startup, to contact some sort of central server, and ask that server to return a list of all the entities in the world. At the same time any participant that publishes an entity would notify the central server of this fact. If DIS were designed in this era, that's probably the design choice that would have been made.  Writing a server back then was considered at least moderately deep magic, and there were few standards for a server API. Some sort of custom API for querying the server would have to be written, and more importantly standardized. 

If DIS was designed today the choice almost certainly would be to use an HTTP server as a central registration point for entities. Web servers are nearly trivially easy to set up, and HTTP is a standards-based interface that could be used. The web server could also be used for some other tasks, such as returning 3D models or terrain. There are a wealth of tools to create custom web services that are still standards-based. Still, this design choice would not be cost free. DIS made the choice to be peer-to-peer and serverless. No server is required to make implementations from different vendors work together. In theory, simulations can simply be started, and they will interoperate out of the box, with no configuration. The reality often falls short of this, as can be seen with the proliferation of gateways.

Another possible solution to the problem would be for the simulation that has just started to ask the other particpants for a list of the entities they publish. Perhaps the simulation that is joining could broadcast a "Give me a list of all your entities" message, and then build a complete picture of the virtual world from the responses. This has some potential problems as well. DIS usually uses UDP, and UDP is unreliable. There is no guarantee that the "give me a list of your entities" message will be received by the other participants, and no guarantee that the responses will be received by the host sending the message. In fact, there may be what is sometimes called an "ack implosion." If a participant sends out a request message and a hundred other participants hear it and respond, then the sender may be overwhelmed by hundreds of responses flooding in at nearly the same time. There are various ways in which this can be mitigated, such as randomized response times, but suddenly the solution we thought would be simple and direct has become more complex.

### What happens 


DIS simply listens on the network for Entity State PDUs. Each ESPDU it receives contains a unique ID and an entity type. As other participants send ESPDUs, our simulation receives the messages and builds a list of the other entities in the virutal world. This approach has a number of virtues. It is very simple to implement, and requires no central server. It works without configuration. 

The hidden assumption in this approach is that the entities must send ESPDUs, even if their state does not change. Imagine a tank sitting still. It's state is not changing, so one might think that it is not necessary to send ESPDUs that just confirm that nothing has changed. That's not the case. Simulations that have recently joined would have no idea that the entity exists. As a result the DIS standard mandates that entities send "heartbeat" messages in the form of ESPDUs every few seconds even if the state of the entity has not changed. This is one of the design trade-offs DIS made: in exchange for a simple and robust entity discovery mechanism, DIS uses more bandwidth because of all the heartbeat messages. The effect can be significant. Even vehicle entities often don't move, and ESPDUs are used to describe some other things, such as minefields or buildings, that never move. In a brigade or high level constructive simulation the network traffic can become quite chatty. There is also an inherent delay in discovering all the entities in the world. A simulation has to wait for at least one heartbeat cycle to discover all entities. It can be worse than this, for example if some ESPDUs are dropped by UDP. It's safer to wait for a few heartbeat cycles when building an entity list.

This also suggests a technique for discovering when an entity has left the virtual world. Since they're required to send an ESPDU every heartbeat cycle, if we fail to hear from an entity we have previously discovered for several cycles, we can assume it has been removed by the publisher.

How long is the hearbeat cycle? It depends. Typical values are 5-10 seconds for air and land vehicles. Stationary entities, such as minefields, may have heartbeats of 60 seconds. It's usually fairly safe to use a heartbeat value of around 10 seconds. It's traditional to set the timeout value to three times the heartbeat rate to allow for dropped UDP messages. For a 10 second heartbeat value that means that if we don't hear from an entity for 30 seconds we can assume that it has left the simulation.

The description above is a small lie. There are also "Create entity" PDUs and "Remove entity" PDUs. Whether these are actually respected by participating simulations is another matter. It may well be that they are simply ignored.

